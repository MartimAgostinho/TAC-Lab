\section{Phase 1}

\subsection{Encoder}

\label{sec:encoder}

This section details the two source-coding strategies \emph{Huffman coding} and a plain \emph{ASCII}. All scripts were written in \textsc{Matlab}.

\label{ssec:huffman}

Firstly, for the \textbf{Huffman encoding}, the number of bits in the bit-stream produced shall be divisible by 4, this is because the message will be sent with 16-QAM and each symbol has 4 bits. By doing this in this stage, the results for all modulators will be comparable, since they will be sending the same message. The padding was implemented by adding spaces at the end of the message until the huffman encoded message was divisible by 4.

The message, once padding has been applied, appears as follows:

\begin{center}
    \begin{verbatim}
"polar codes are employed in 5g due better performance and simplicity   "
    \end{verbatim}
    
\end{center}

For the padded test sentence (71 symbols) the huffman alphabet is described by Table \ref{tab:huffCode}.

\begin{table}[H]
    \centering
    \caption{Message Huffman Coding}
    \begin{tabularx}{\textwidth}{>{\centering\arraybackslash}X >{\centering\arraybackslash}X >{\centering\arraybackslash}X >{\centering\arraybackslash}X}
        \toprule
        \textbf{Character} & \textbf{Probability} & \textbf{Code} & \textbf{Code Length} \\
        \midrule
        ' ' & 0.183099 & 11 & 2\\
        \midrule
        '5' & 0.014085 & 0000011 & 7\\
        \midrule
        'a' & 0.056338 & 0111 & 4\\
        \midrule
        'b' & 0.014085 & 0110001 & 7\\
        \midrule
        'c' & 0.042254 & 00100 & 5\\
        \midrule
        'd' & 0.056338 & 1001 & 4\\
        \midrule
        'e' & 0.126761 & 010 & 3\\
        \midrule
        'f' & 0.014085 & 011001 & 6\\
        \midrule
        'g' & 0.014085 & 0110000 & 7\\
        \midrule
        'i' & 0.056338 & 1010 & 4\\
        \midrule
        'l' & 0.042254 & 00101 & 5\\
        \midrule
        'm' & 0.042254 & 00010 & 5\\
        \midrule
        'n' & 0.042254 & 00001 & 5\\
        \midrule
        'o' & 0.056338 & 1011 & 4\\
        \midrule
        'p' & 0.056338 & 1000 & 4\\
        \midrule
        'r' & 0.070423 & 0011 & 4\\
        \midrule
        's' & 0.028169 & 01101 & 5\\
        \midrule
        't' & 0.042254 & 00011 & 5\\
        \midrule
        'u' & 0.014085 & 0000010 & 7\\
        \midrule
        'y' & 0.028169 & 000000 & 6\\
        \bottomrule
    \end{tabularx}
    \label{tab:huffCode}
\end{table}

The coding has the following characteristics:

\begin{itemize}
  \item Bitstream Length $\lvert c\rvert = 284$ bits,
  \item Average Code Length $\bar L = 4.00$ bits/symbol,
  \item Entropy $H(X)=3.95$ bits/symbol
\end{itemize}



The \textbf{ASCII} encoding works as a benchmark, each character using its standard 8-bit representation. No padding is required because very symbol uses a entire byte making it always divisible by 4. The 

There are somethings importante to note, as just said, the ASCII will be sending less symbols per phrase sent, since there is no padding. With Huffman the average number of bits sent, will be half the number bits comparing to ASCII, making it much more efficient but, this is for the specific case of sending this specific phrase. 

